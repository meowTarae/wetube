#6.0
드디어 백엔드에 대하여 배워보자!
백엔드엔 데이터들이 있겠지.

이제 app.get, get만 하는게 아니라
Post를 해야되.

일단 백엔드에 data를 post하는 방법부터 배우자 !

ES6
const { id } = req.params;
= const id = req.params.id;



#6.1
pug에서는 #{~ ? ~ : ~}
앞에 #붙여서 쓰자

absolute url 과 relative url

현 위치
localhost:4000/users/edit-profile/password

a(href="/login") 
=> localhost:4000/login

a(href="login") 
=> localhost:4000/users/edit-profile/login 
현 위치에 login이 붙음 

그럼 ~~password/login으로 가고싶다?
a(href="password/login") 혹은
a(href=`${video.id}/login`) 라고 적으면 되겠지 ㅇㅇ

relative url은 맨앞에 / 없는거라고 생각하자.



#6.2
get -> 네이버나 구글에서 검색을 할 때,
검색값이 url에 포함이 됨

post -> 파일을 보내거나, DB에 있는 값을 바꾸는 등에 사용



#6.3
get, post를 한줄로 줄이면
videoRouter.route("경로").get(함수).post(함수);

redirect
브라우저가 자동으로 이동하도록 해줌


express app에서 form(html)을 처리하는 방법
=> `urlencoded`
app.use(express.urlencoded({ extended: true }));


req.body로 user가 form에 입력한 값을 얻을 수 있음
(input에 name을 줘야만 값을 얻을 수 있음!)    



#6.8
MongoDB

설치
mongo 홈페이지에서 다운 후 
cmd에서 ' cd MongoDB의 bin 설치 파일 경로 ' 입력 후 
mongod, mongo를 입력함
view dbs를 입력했을 때 값이 나오면 정상.


사용법
db로 쓸 js파일 생성

import mongoose from "mongoose";

mongoose.connect("mongodb://127.0.0.1:27017/wetube"); 를 입력
(wetube는 서버명임)

메인 서버 js파일에서는
import "./db" 로, import값만 입력하면 된다.

db.on -> 여러번 발생 가능
db.once -> 한번만 ``



#6.9
mongoose는 우리가 mongoDB와 대화할 수 있게 해줌
mongoose를 사용하려면 도움을 줘야 함.
 => 데이터들이 어떻게 생겼는지, `모델`을 만들어서 알려주자.

db는 모델의 데이터가 어떻게 생겼는지 알아야 함
어떤 item이 있는지, 속성은 어떤지(= string인지 num인지)를 말이다.



#6.10
schema
db에서 형식을 지정할때 사용됨

const videoSchema = new mongoose.Schema({
    title: { type: String },
        or
    title: String,
    // 두 방식 모두 사용 가능.
    createdAt: Date,
    hashtags: [{ type: String }],
    // 배열로 사용하려면 위 방식으로.
});

schema를 만들어줬다면,
const Video = mongoose.model("Video", videoSchema);
                        // 아무 이름, 함수명

model 파일 맨 위에는 
import mongoose를 해줌으로써
db와 연동해준다.

그리고 server.js에도 video를 사용한다고 import 해줘야함.
그래서 마지막에 export까지 해주면 됨.



#6.11
server.js는 express 관련된 것만,
init.js는 model, db 관련된 것만.


controller 파일에서 model 파일을 활용하려면 먼저 import를 하자.

find() 로 db에 접근 가능해.

find() 에는 2가지 작동 방식이 있어.
1. callback
   -> Call func when after something happens 
2. promise
   -> callback의 최신 버전
      


#6.12
<callback explanation>

video.find({}, (err, videos)=>{
    ~~
});

// {} => search terms, null == all schemas.
// (terms는 schema에서 title이라던가 hashtags같은 것)
// , () => err와 docs(= documents)를 수신

callback의 작동 순서로는
page를 먼저 req하고
render과정을 거쳐야 logger를 얻게 됨
-> db 검색이 안 끝났을 때 render 되는 것을 방지해줌.
   하지만 순서가 꼬임

err 발생 시, find() 내부 func의 err argu를 
바로 활용할 수 있는 장점이 있음.



#6.13
<promise explanation>
== Async await

export const home = (req, res) => {} 를
export const home = async(req, res) => {
    const videos = await Video.find({});
} 로 나타내주면 됨


작업별로 시간이 달라 꼬이는 js때문에
callback 이 만들어졌고,
await는 db로 부터 값을 받기까지 계속 기다려주기에
순서가 꼬일 일이 없음.


대신 err를 잡아내려면 try / catch를 사용함.
try{
    const videos = await Video.find({});
    ~~
} catch(error) {
    return res.req("error");
}

try로 돌리다가 await에 err가 발생하면
catch 함수로 점프해줌. 



#6.14
return을 사용하는 이유

ex) return res.render(~~)
-> func이 render 작업 후 종료되기 위함
-> return은 적어줌으로써 뒤에 뭔가 더 적는 실수를 줄여주는 역활.

== 없어도 되긴 함


#6.15
split
string들을 분리하는 역활

ex) ["hi,food,tarae"].split(",") 
 => ["hi", "food", "tarae"] 로 변경됨.
    
+) map 활용
    tags.split(",").map((word) => `@{word}`)
    => ["@hi", "@food", "@tarae"]



