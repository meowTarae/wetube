쉘 
    보호막역할

    명령ㅇ(유틸리티)
    어떤 명령어를 실행 해 줘야할지

    유틸리티는 bin(일반사용자)이나 sbin(관리자용)에 준비되어있음



command ~~~ ~~~
    여기서 ~~~는 arg라 부른다
    
    옵션은 -이나 --로 
    
    -을 일반적으로 쓰려면, 
    
    $ls -- -l  -> --뒤는 모두 인자 처리
    $ls ./-l  -> 파일명이 -l인 친구로 해석함.



명령어 입력/처리과정
    우리가 코드 적고 엔터 누르면,
    1. '파싱' -> 2. 명령어 존재하는지 확인 -> 실행

        1) 파싱이란? 
        먼저 문법적으로 맞는지 확인하고, 인자(arg)들을 추출

        2) 
        코드에서 명령어가 어디에 존재하는지 확인
        찾을 위치는 PATH에 있당

    2. 명령어 실행 과정
        2단계를 거침
        spawn, exec

        spawn?  쉘을 자기랑 동일한 자식쉘을 복제해만든다
        복제된거 말고 원래 쉘은 sleep모드에 들어감
        그런다음, exec를 거침.
        유저가 입력한 코드의 명령어(ls라고 가정)를 저장소(bin)에서 가져와서 /bin/ls
        로딩을 해주는 역할 = 복제된 자식쉘에 /bin/ls를 탑재한다

        마지막에 exec 과정 후, 커널이 exec를 받고, 원래 쉘을 wake up함



표준 입력, 표준 출력
    표준 입출력
    0 = 입력, 1 = 출력, 2 = 에러 출력
    0,1,2는 FDE라고 부름
    모든 프로세스는 3개 입출력을 가지고 태어남
    
    tty 명령어 : 쉘의 표준입력이 연결된 터미널의 장치파일 확인
    ex /dev/pts/12



리디렉션
    방향을 재지정
    > : 출력을 ~ , < : 입력을~
        ex)
        $ ls > file 
        원래는 커맨드 -> 터미널인데,  방향이 커맨드 -> 파일로 변경됨
        파일에 있던 기존값은 날아감

        $ cat > sample.txt
        키보드에서 받은 값을 sample.txt에 넣어줌

        $ cat < file
        원래 키보드에서 값을 받는데, 이 경우 file에서 값을 받아오는걸로 바뀜

    noclobber : 리다이렉션에서 덮어쓰기 못하게함
        $ set -o noclobber     : 덮어쓰기 방지
        $ set +o noclobber     : 덮어쓰기 방지 해제
        $ cat pear >> orange   : 이어쓰기
        ! 중요 ! 
        $ date >| a            : 강제로 덮어쓰기 허용
        참고 : mv랑 cp에는 noclobber가 작동 안됨

    /dev/null
        데이터를 버릴때 사용함.
            ex)
            $echo "hi" > /dev/null 
            아무 출력을 하지 않는다

            $ cat /dev/null > messages
            빈값을 메세지로, 즉 메세지 파일이 비워지겠지

            왜 이런짓을 하냐. 비울거면 삭제를 하면 되지 않냐.
            -> 소유자 속성과 접근 모드를 유지한 채 파일을 비우기 위해서 사용함.



파이프
    자주 쓰는 명령어로는
        tr : translate, 내용을 변환
            $ cat abstract | tr abc ABC  : abstract파일에 abc라는 단어를 ABC로

        lpr : 파이프 앞에 내용을 출력   
            $ ls | lpr			: ls 내용을 출력

        grep : 원래는 특정 문자 패턴을 찾는데 사용
            (grep 쓰면 우분투에서 출력 문구가 빨간색으로 강조됨)
            $ who | grep 'root'
            grep 하고 패턴하고 파일이름을 주는데, 
            이 예제는 파일명이 없네, 앞에 파이프로 파일 이름을 입력 받아서 사용하는 케이스

        less, more : 화면에 출력되는 내용의 길이를 조절
            $ ls | less

    필터 명령어 : 파이프와 파이프 사이에 낀 명령어
        ex
            $ who | tee out.txt | grep root
            tee out.txt가 필터 명령어겠지?


백그라운드로 명령 실행
    포어그라운드란?
    프로그램의 실행이 전면에 드러낸 상태로 실행
    표준 입출력을 사용자가 로그인한 터미널 그대로 유지한 채로 실행
        => 입력 후 바로 출력이 나오는 형태
    
    백그라운드란? 
    프로그램이 뒤로 숨어서 실행되고 있는 상태
    ps -ef 해서 나오는 거의 모든 프로세스가 백그라운드 상태의 실행이다. 
    백그라운드로 실행시키려면 명령줄 끝에 ‘&’ 특수문자를 사용한다.
    그러면, 표준 입출력을 /dev/null 로 만들어서 프로그램을 실행 후, 원래의 쉘로 되돌아온다.
    
    만약, cat처럼 표준입출력이 있어야만 실행이 가능한 경우에는, '중지 상태'로 대기하게 된다.
    이때, 해결법 2가지 외워두자.
        1. 백그라운드 -> 포어그라운드로 전환
            fg 1    ->      컨트롤 c
        2. 백그라운드에서 job ID를 확인 후, kill로 종료 시키기
            jobs    ->      kill %1     ->      fg 1
            (숫자 1이 job의 id 인거같다)


파일명 확장 기능
    ? - a? 면 aw, as 찾아줌
    * - 모든 파일 찾아줌 ㅇㅇ
        a*txt면 aa.txt, aaa.txt...

    둘 다 파일 찾아주는 역할이네 ㅇㅇ

    ls [a-d]*  - a, b, c, d로 시작하는 파일명을 모두 출력 (하위 폴더들 까지)
    ls *[a-d]  - 파일명이 a, b, c, d 로 끝나는 파일들을 출력
    ls *[^a-d]  - ^는 not, 위에 것이 아닌 애들 출력해줌.


ctrl + H = 1 단어 지우기
ctrl + W = 단어절 하나 지우기
ctrl + U = 한 문장 지우기

